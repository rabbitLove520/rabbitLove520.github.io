<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Linux - 分类 - 猪爱兔的网站</title><link>https://rabbitLove520.github.io/categories/linux/</link><description>Linux - 分类 - 猪爱兔的网站</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Thu, 02 Jul 2020 11:00:00 +0000</lastBuildDate><atom:link href="https://rabbitLove520.github.io/categories/linux/" rel="self" type="application/rss+xml"/><item><title>gdb调试简单使用</title><link>https://rabbitLove520.github.io/gdb_use/</link><pubDate>Thu, 02 Jul 2020 11:00:00 +0000</pubDate><author>Salamander</author><guid>https://rabbitLove520.github.io/gdb_use/</guid><description>&lt;h2 id="gdb">gdb&lt;/h2>
&lt;p>gdb 是 UNIX 及 UNIX-like 下的调试工具，在 Linux 下一般都直接在命令行中用 gdb 来调试程序，相比 Windows 上的集成开发环境 IDE 提供的图形界面调试，一开始使用 gdb 调试可能会让你感觉很难适应，但是只要熟悉了 gdb 调试的常用命令，调试出程序会很有成就感，一方面因为这些命令就类似图形界面调试按钮背后的逻辑，另一方面用命令行来调试程序，逼格瞬间就上了一个档次，这次就跟大家分享 gdb 调试的基本技术和 15 个常用调试命令。&lt;/p></description></item><item><title>一步步自己做个Docker之Docker网络原理</title><link>https://rabbitLove520.github.io/step_to_step_docker%E4%B9%8Bdocker_network_underlying/</link><pubDate>Tue, 28 Apr 2020 15:00:00 +0000</pubDate><author>Salamander</author><guid>https://rabbitLove520.github.io/step_to_step_docker%E4%B9%8Bdocker_network_underlying/</guid><description><![CDATA[<p></p>
<p>本文环境：</p>
<ul>
<li>OS：Ubuntu 18.04.4 LTS</li>
<li>Golang版本：1.12.13</li>
</ul>
<!-- more -->
<h2 id="自己创建docker网络">自己创建Docker网络</h2>
<blockquote>
<p>当 Docker 启动时，会自动在主机上创建一个 docker0 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。 同时，Docker 随机分配一个本地未占用的私有网段（在 RFC1918 中定义）中的一个地址给 docker0 接口。比如典型的 172.17.42.1，掩码为 255.255.0.0。此后启动的容器内的网口也会自动分配一个同一网段（172.17.0.0/16）的地址。 当创建一个 Docker 容器的时候，同时会创建了一对 veth pair 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 eth0；另一端在本地并被挂载到 docker0 网桥，名称以 veth 开头（例如 vethAQI2QT）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。如图
</p>]]></description></item><item><title>Linux之iptables</title><link>https://rabbitLove520.github.io/linux_iptables/</link><pubDate>Sun, 26 Apr 2020 13:00:00 +0000</pubDate><author>Salamander</author><guid>https://rabbitLove520.github.io/linux_iptables/</guid><description><![CDATA[<h2 id="简介">简介</h2>
<p>管理网络流量是系统管理员必需处理的最棘手工作之一，我们必需规定连接系统的用户满足防火墙的传入和传出要求，以最大限度保证系统免受攻击。<code>iptables</code>正是这样的工具。</p>]]></description></item><item><title>Linux网络虚拟化技术之Veth和Bridge</title><link>https://rabbitLove520.github.io/linu_veth_and_bridge/</link><pubDate>Tue, 14 Jan 2020 13:00:00 +0000</pubDate><author>Salamander</author><guid>https://rabbitLove520.github.io/linu_veth_and_bridge/</guid><description><![CDATA[<h2 id="veth">Veth</h2>
<p>Veth缩写是Virtual ETHernet。veth设备是在linux内核中是成对出现（所以也叫<code>veth-pair</code>），两个设备彼此相连，一个设备从协议栈读取数据后，会将数据发送到另一个设备上去。这个设备其实是专门为<code>container</code>所建的，作用就是把一个<strong>network namespace</strong>发出的数据包转发到另一个<strong>namespace</strong>（通常就是宿主机）。 <br>
</p>]]></description></item><item><title>Linux网络虚拟化技术之tun/tap</title><link>https://rabbitLove520.github.io/tun-tap/</link><pubDate>Mon, 13 Jan 2020 15:00:00 +0000</pubDate><author>Salamander</author><guid>https://rabbitLove520.github.io/tun-tap/</guid><description><![CDATA[<p>我们都知道，Linux实际是通过<strong>网络设备</strong>去操作和使用网卡的，系统安装了一个网卡之后会为其生成一个网络设备实例，比如<strong>eth0</strong>（或者叫<strong>enp7s0</strong>，不同发行版默认网卡命名规则不同）。随着网络虚拟化技术的发展，Linux支持创建出虚拟化的设备，可以通过虚拟化设备的组合实现多种多样的功能和网络拓扑。<br>
常见的虚拟化设备有<strong>tun/tap</strong>、<strong>Veth</strong>、<strong>Bridge</strong>、<strong>802.1q VLAN device</strong>。</p>]]></description></item></channel></rss>